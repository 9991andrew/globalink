<?php

/**
 * A player character (not a user). The largest class. Contains functions to manipulate the data of a player.
 *
 * A Player may be constructed with all the data (default) or as a "simple" Player
 * which does fewer database lookups when detailed information about a Player's inventory,
 * Professions, and Skills are not required. This simple Player is used, for example,
 * on the map to show other Players than the current Player.
 */
class Player extends Dbh {
    protected $id;
    protected $visible;
    protected $userId; // player's owner, could also make this the user class, maybe
    // Name user logs in with
    protected $name;
    protected $birthplaceId;
    protected $mapId; // These keep track of the player's location in the world
    protected $x;
    protected $y;
    protected $lastActionTime;
    protected $mapEnterTime;
    protected $health;
    protected $healthMax;
    protected $money;
    // The db level field is not used. We use profession level instead and just take the maximum level attained in any profession
    protected $maxLevel;
    protected $experience;
    protected $reputeRadius;
    protected $movement;
    protected $travel;
    protected $attack;
    protected $defence;
    protected $bonusPoint;
    protected $raceId;
    // Also store name of race
    protected $raceName;
    protected $genderId;
    protected $genderName;
    protected $isSuper;
    // Array of equipped items (on avatar)
    protected $playerAvatarImages;
    // Array of equipped items (on Guardian avatar)
    protected $guardianAvatarImages;
    // Array of stored items (in bag)
    protected $playerItemsStored;
    // Array of player's stats
    protected $stats;
    // Array of player's professions
    protected $professions;
    // array of skill Ids possessed by the player
    protected $skillIds;
    // array of PlayerQuest objects
    protected $playerQuests;
    // Playerbag object
    protected $bag;
    // Array of other players on the map with the player within range
    protected $visiblePlayers;


    /**
     * Create a new player, pass all required attributes as arguments
     * @param int $userId
     * @param string $name
     * @param int $birthplaceId
     * @param int $raceId
     * @param int $genderId
     * @param array $attributeValues
     * @return Player
     * @throws NoBagSlotsAvailableException
     */
    public static function create(int $userId, string $name, int $birthplaceId, int $raceId, int $genderId, array $attributeValues):Player {
        // Insert into the DB, then invoke the constructor
        $dbh = new Dbh();

        // Get coordinates of birthplace. If I end up using birthplace for other things I could make a class for this
        $sql = "SELECT id, map_id, x, y, name, description FROM birthplaces WHERE id = ?;";
        $stmt = $dbh->connect()->prepare($sql);
        $stmt->execute([$birthplaceId]);
        $birthplace = $stmt->fetch(PDO::FETCH_ASSOC);

        // map_id, x, y are optional as we'll typically just use the birthplace location
        $sql = "INSERT INTO players (
            user_id,
            name, 
            birthplace_id,
            visible,
            map_id,
            x,
            y,
            last_action_time,
            map_enter_time,
            health, health_max, money,
            experience, repute_radius,
            movement,
            travel,
            attack,
            defence,
            bonus_point,
            race_id,
            gender_id,
            is_super)
        VALUES(
            ?,
            ?,
            ?, 
            0, -- initially invisible
            ?,
            ?,
            ?,
            NOW(), -- current time for last_action_time
            NOW(), -- current time for map_enter_time
            100, 100, 100, -- health, health_max, money default to 100
            0, 0, -- level, experience, repute_radius
            ?, -- movement (used to be 99 by default)
            0, -- travel
            10, -- attack
            10, -- defence
            0, -- bonus_point
            ?,
            ?,
            0
        );";
        $conn = $dbh->connect();
        $stmt = $conn->prepare($sql);

        $stmt->execute([
            $userId,
            $name,
            $birthplaceId,
            $birthplace['map_id'], 
            $birthplace['x'],
            $birthplace['y'],
            Config::INITIAL_MOVEMENT_POINTS,
            $raceId,
            $genderId]);
        // get the new id
        $playerId = (int)$conn->lastInsertId();


        // If we received an array of new attribute values, we can insert those now
        // I'm not super worried about $id being handled as it's generated by the code above,
        // not passed by another user or script
        $sql = "DELETE FROM player_base_attributes WHERE player_id = $playerId;";
        $sql.= "DELETE FROM player_stats WHERE player_id = $playerId;";
        $sql.= "INSERT INTO player_base_attributes (player_id, attribute_id, attribute_value) VALUES ";
        $i = 0;
        foreach($attributeValues as $attribute => $attributeValue) {
            if ($i++ > 0) $sql.=", ";
            $sql.="($playerId, $attribute, $attributeValue)";
        }
        $sql.="; ";
        // Finally, add the query that inserts new computed player_stats
        $sql.="INSERT INTO player_stats (player_id, stat_id, stat_value) SELECT * FROM player_stats_initial_view WHERE player_id = $playerId;";

        // Log the creation of the new player
        $sql.="INSERT INTO player_actions_log (user_id, player_id, map_id, x, y, event_time, action_type_id, note) VALUES
            (?, ?, ?, ?, ?, NOW(3), ?, NULL);";

        $stmt = $dbh->connect()->prepare($sql);
        $stmt->execute([$userId, $playerId, $birthplace['map_id'], $birthplace['x'], $birthplace['y'], Actions::CREATE_PLAYER]);

        // instantiate the new player
        $player = new self($playerId);

        // Randomly assign the new player avatar items
        Player::generateRandomAvatar($player);

        // Now return the new user
        return $player;

    }// end create static method

    /**
     * Randomly generates a new avatar. Used in new player creation.
     * @param $player Player The player to receive the new avatar
     */
    static public function generateRandomAvatar($player)
    {
        $dbh = new Dbh();
        // Get list of random avatar items, one for each category.
        // Pick primary and secondary colors for all items, leave tertiary to null (which should be rendered as transparent)
        $sql = "SELECT ait.id,
            (SELECT id FROM avatar_images WHERE avatar_image_type_id=ait.id
                    AND (race_id = ? OR race_id IS NULL) AND (gender_id = ? OR gender_id IS NULL)
                    ORDER BY RAND() LIMIT 1) AS avatar_image_id,
            (SELECT css_color FROM avatar_image_type_colors WHERE avatar_image_type_id=ait.id ORDER BY RAND() LIMIT 1) AS color1,
            (SELECT css_color FROM avatar_image_type_colors WHERE avatar_image_type_id=ait.id ORDER BY RAND() LIMIT 1) AS color2
        FROM avatar_image_types ait
        -- Don't pick items when there are no options
        WHERE (SELECT COUNT(1) FROM avatar_images WHERE avatar_image_type_id=ait.id
            AND (race_id = ? OR race_id IS NULL) AND (gender_id = ? OR gender_id IS NULL)) > 0;";
        $stmt = $dbh->connect()->prepare($sql);
        $stmt->execute([
            $player->getRaceId(),
            $player->getGenderId(),
            $player->getRaceId(),
            $player->getGenderId()
        ]);
        $avatarParts = $stmt->fetchAll(PDO::FETCH_ASSOC);

        // Now loop through categories and randomly select an item from each, give that to the player
        foreach($avatarParts as $avatarPart) {
            if (!is_null($avatarPart['id']))
                $player->addAvatarImage((int)$avatarPart['avatar_image_id'], $avatarPart['color1'], $avatarPart['color2']);
        }
    }


    /**
     * countPlayersWithName simply returns an integer of the number of players that have a given name.
     * This is used when creating a player to prevent users from creating duplicate player names so they
     * must be unique.
     * @param $playerName string
     *
     */
    public static function countPlayersWithName(string $playerName):int {
        $dbh = new Dbh();
        $sql = "SELECT COUNT(*) FROM players WHERE name = ?;";
        $stmt = $dbh->connect()->prepare($sql);
        $stmt->execute([$playerName]);
        return (int)$stmt->fetchColumn();
    }

    /**
     * getPlayerIdWithName returns the id for the player with the specified name.
     * Useful in testing, could probably replace countPlayersWithName()
     * @param $playerName string
     */
    public static function getPlayerIdWithName(string $playerName):int {
        $dbh = new Dbh();
        $sql = "SELECT id FROM players WHERE name = ?;";
        $stmt = $dbh->connect()->prepare($sql);
        $stmt->execute([$playerName]);
        return (int)$stmt->fetchColumn();
    }

    /**
     * Player constructor. Needs a id.
     * @param int $id - Id of the player from the players table
     * @param bool $simple - If set to true, several unnecessary queries will not be performed.
     *          This is to make creating many player objects more efficient when we
     *          don't need all the item and stat details (such as getting all players on a map)
     * @param bool $enterGame If true, sets last_action_time to NOW()
     * @throws Exception
     */
    public function __construct($arg, bool $simple=null, bool $enterGame=null)
    {
        // $simple defaults to false
        if (is_null($simple)) $simple=false;

        if (is_int($arg)) {
            $playerId=$arg;
            // Look up information about given player.
            // Check that player exists and throw exception if not.
            $sql = "SELECT p.id, p.name, user_id, birthplace_id, visible, map_id, x, y, last_action_time, map_enter_time,
            health, health_max, money, experience, repute_radius, movement, travel, attack, defence, last_retrieval_time,
            bonus_point, race_id, r.name AS race_name, gender_id, g.name AS gender_name, is_super
            FROM players p
            JOIN races r ON p.race_id=r.id
            JOIN genders g ON p.gender_id=g.id
            WHERE p.id = ?;
            UPDATE players SET visible=0 WHERE visible=1 AND TIMESTAMPDIFF(SECOND, last_action_time, NOW()) > ?;";
            $stmt = $this->connect()->prepare($sql);
            $stmt->execute([$playerId, Config::VISIBLE_FOR_SECONDS]);
            $count = $stmt->rowCount();
            // I suppose here I can use a try/catch to make this more user-friendly
            if ($count == 0) throw new InvalidPlayerException($playerId);
            $arg = $stmt->fetch();

        } else if (!is_array($arg)) {
            // $arg isn't valid
            throw new InvalidPlayerException();
        }

        $this->id = (int)$arg['id'];
        $this->userId = (int)$arg['user_id'];
        $this->name = $arg['name'];
        $this->birthplaceId = (int)$arg['birthplace_id'];
        $this->visible = $arg['visible']==1;
        $this->mapId = (int)$arg['map_id'];
        $this->x = (int)$arg['x'];
        $this->y = (int)$arg['y'];
        $this->lastActionTime = $arg['last_action_time'];
        $this->mapEnterTime = $arg['map_enter_time'];
        $this->health = (int)$arg['health'];
        $this->healthMax = (int)$arg['health_max'];
        $this->money = (int)$arg['money'];
        $this->experience = (int)$arg['experience'];
        $this->reputeRadius = (int)$arg['repute_radius'];
        $this->movement = (int)$arg['movement'];
        $this->travel = (int)$arg['travel'];
        $this->attack = (int)$arg['attack'];
        $this->defence = (int)$arg['defence'];
        $this->bonusPoint = (int)$arg['bonus_point'];
        $this->raceId = (int)$arg['race_id'];
        $this->raceName = $arg['name'];
        $this->genderId = (int)$arg['gender_id'];
        $this->genderName = $arg['gender_name'];
        $this->isSuper = $arg['is_super'];

        // If we specify that the player is entering the game, we update
        // their last_action time so they show as visible to other players
        // and their map_enter_timeso they only see chat messages since they entered the game
        if (!is_null($enterGame) && $enterGame==true) {
            $sql = "UPDATE players SET visible=1, last_action_time=NOW(), map_enter_time=NOW() WHERE id = ?";
            $stmt = $this->connect()->prepare($sql);
            $stmt->execute([$this->id]);
            $this->lastActionTime = date("Y-m-d H:i:s");
        }

        // We always need this to be able to render the player's avatar image.
        $this->refreshPlayerAvatarImages();

        // If $ simple is not true, add extended data to the object.
        if (!$simple) {

            $sql = "SELECT player_id, ps.stat_id, stat_value, stats.name AS stat_name FROM player_stats ps
                JOIN stats ON stats.id=ps.stat_id
                WHERE player_id = ? ORDER BY stat_id;";
            $stmt = $this->connect()->prepare($sql);
            $stmt->execute([$playerId]);

            // Stats will be stored in a simple array. First element (0) is the player's Id, other elements are just the value,
            // index of the element is the statid str, int, etc
            // $this->stats = $stmt->fetchAll();
            $this->stats = array();
            array_push($this->stats, $this->id);
            while  ($row = $stmt->fetch()) {
                $val = $row['stat_value'];
                // Round attack to 3 digits
                if ($row['stat_id'] == 7) $val = round($val*1000)/1000;
                array_push($this->stats, (int)$val);
            }

            // This part of the game isn't really used right now
            $sql = "SELECT skill_id FROM player_skills WHERE player_id = ?;";
            $stmt = $this->connect()->prepare($sql);
            $stmt->execute([$playerId]);
            $this->skillIds = array();
            while ($row = $stmt->fetch()) {
                array_push($this->skillIds, (int)$row['skill_id']);
            }

            $this->bag = new PlayerBag($this->id);

            $this->refreshPlayerProfessions();

            $this->refreshPlayerQuests();

            $this->refreshPlayerItems();

        } // end extended !$simple data

    }

    /**
     * logSelect simply logs the selection of a player by its user to the player_actions_log
     */
    public function logSelect() {
        $sql = "INSERT INTO player_actions_log (user_id, player_id, map_id, x, y, event_time, player_action_type_id, note) VALUES
        (?, ?, ?, ?, ?, NOW(3), ?, NULL);";
        $stmt = $this->connect()->prepare($sql);
        $stmt->execute([$this->userId, $this->id, $this->mapId, $this->x, $this->y, Actions::SELECT_PLAYER]);
    }


    // Self-explanatory getters, not adding PHPDoc unless there's some good reason to

    public function getId() {return $this->id;}
    public function getUserId() {return $this->userId;}
    public function getName() {return $this->name;}
    public function getVisible() {return $this->visible;}
    public function getRaceId() {return $this->raceId;}
    public function getRaceName() {return $this->raceName;}
    public function getGenderId() {return $this->genderId;}
    public function getGenderName() {return $this->genderName;}
    public function getMapId() {return $this->mapId;}
    public function getX() {return $this->x;}
    public function getY() {return $this->y;}
    public function getHealth() {return $this->health;}
    public function setHealth(int $health) {$this->health = $health;}
    public function getHealthMax() {return $this->healthMax;}
    public function getMovement() {return $this->movement;}
    public function getMoney() {return $this->money;}
    public function getMana() {return $this->stats[8];}
    public function getPlayerAvatarImages() {return $this->playerAvatarImages;}
    public function getGuardianAvatarImages() {return $this->guardianAvatarImages;}
    public function getPlayerItemsStored() {return $this->playerItemsStored;}
    public function getLastActionTime() {return $this->lastActionTime;}
    public function getMapEnterTime() {return $this->mapEnterTime;}
    public function getStats() {return $this->stats;}
    public function getProfessions() {return $this->professions;}
    public function getMaxLevel() {return $this->maxLevel;}
    public function getExperience() {return $this->experience;}
    public function getPlayerQuests() {return $this->playerQuests;}

    /** 
    * getPlayerBag()
    * Returns instance of PlayerBag class for this player's main bag
    */
    public function getPlayerBag() {return $this->bag;}


    /**
     * showAvatar() returns a div with all the avatar parts displayed within
     * @return string
     */
    public function showAvatar() {
        $html = "";
        // CSS padding hack to preserve aspect ratio. Real aspect ratio support is coming to CSS soon!
        $html .= '<div class="avatar relative w-full" style="padding-bottom:139%;">';
        $html .= '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 330 460" id="pa'.$this->id.'" class="absolute inset w-full h-auto">';
        foreach ($this->playerAvatarImages as $image) {
            $html .= Helpers::svgClean((string)$image->getSvgCode(), $image->getAvatarImageTypeId(), $image->getColor1(), $image->getColor2(), $image->getColor3(), $image->getColor4());
        }
        $html .= '</svg>';
        $html .= '</div>';
        return $html;
    }

    /**
     * Updates the player's professions array
     */
    private function refreshPlayerProfessions() {
        // Get the array of player professions
        $sql = "SELECT pp.player_id, p.id, pp.profession_xp, pp.profession_level, p.name, p.require_all_prerequisites,
            (SELECT 1 FROM profession_prerequisites pr2 WHERE pr2.profession_id=p.id LIMIT 1) AS has_prerequisite,
            (SELECT SUM(divide_xp) FROM profession_leveling_view WHERE profession_id=pp.profession_id AND level<=pp.profession_level) as next_level_xp,
            (SELECT MAX(level) FROM profession_leveling_view WHERE profession_id=pp.profession_id) as max_level
            FROM player_professions pp JOIN professions p ON p.id=pp.profession_id
            WHERE player_id = ?;";
        $stmt = $this->connect()->prepare($sql);
        $stmt->execute([$this->id]);

        // Create an array of PlayerProfession objects
        // Also get the player's maximum level in any profession
        $this->maxLevel = 0;
        $this->professions = array();
        while ($row = $stmt->fetch()) {
            $pr = new PlayerProfession($row);
            if ($this->maxLevel < $pr->getProfessionLevel()) $this->maxLevel=$pr->getProfessionLevel();
            array_push($this->professions, $pr);
        }
    }


    /**
     * Updates the array of a player's PlayerQuest objects.
     */
    private function refreshPlayerQuests() {
        $sql = "SELECT pq.player_id, pq.pickup_time, pq.success_time, q.id, q.name, repeatable, repeatable_cd_in_minute,
           level, giver_npc_id, target_npc_id, prologue, content, target_npc_prologue, npc_has_quest_item,
           quest_result_type_id, success_words, failure_words, cd_in_minute, result, result_map_id, result_x, result_y,
           base_reward_automark_percentage, reward_profession_xp, reward_xp, reward_money, waiting_words,
           qrt.name AS quest_result_type_name, qrt.uses_items, qrt.uses_bool, qrt.uses_string, qrt.uses_answers, qrt.uses_variables, qrt.uses_automark
            FROM player_quests pq
            JOIN quests q ON pq.quest_id=q.id
            JOIN quest_result_types qrt ON qrt.id=q.quest_result_type_id
            WHERE pq.player_id= ? AND success_time IS NULL ORDER BY pickup_time;";
        $stmt = $this->connect()->prepare($sql);
        $stmt->execute([$this->id]);

        $this->playerQuests = array();
        while ($row = $stmt->fetch()) {
            array_push($this->playerQuests, new PlayerQuest($row));
        }
    }

    /**
    * refreshPlayerItems() just updates the arrays that keep track of the
    * playeritemsStored and playerAvatarImages arrays. This function is run within
    * methods that affect player items.
    * 
    */
    public function refreshPlayerItems() {

        // Array of player items
        $sql = "SELECT pi.id AS player_item_id, pi.guid, pi.item_id, pi.quest_id, pi.player_id, pi.is_equipped, pi.bag_slot_id, pi.bag_slot_amount, pi.item_id, i.id, i.name, i.item_category_id, ic.name as item_category_name, i.description,
            i.item_effect_id, i.effect_parameters, i.weight, i.required_level, i.level, i.price, i.amount, i.max_amount,
            i.item_icon_id, ico.name AS icon_name
            FROM player_items pi
            LEFT JOIN items i ON i.id=pi.item_id
            LEFT JOIN item_categories ic ON i.item_category_id=ic.id
            LEFT JOIN item_icons ico ON i.item_icon_id=ico.id
            -- LEFT JOIN icon_extensions itemext ON i.icon_extension_id=itemext.id
            WHERE player_id = ? ORDER BY bag_slot_id;";
        $stmt = $this->connect()->prepare($sql);
        $stmt->execute([$this->id]);
        $this->playerItemsStored = array();

        // We can create items with no DB query by passing the whole row to the PlayerItem constructor
        while ($row = $stmt->fetch())
        {
                array_push($this->playerItemsStored, new PlayerItem($row));
        }
    } // end refreshPlayerItems


    /**
     * refreshPlayerAvatarImages() updates the array of images used by the player's avatar
     */
    private function refreshPlayerAvatarImages()
    {
        $sql = "SELECT pai.player_id, ai.id, ai.name, ai.filename, ai.svg_code, color1, color2, color3, color4, ait.layer_index, ai.disabled,
        ai.avatar_image_type_id, ai.gender_id, ai.race_id, ai.color_qty, ait.name as avatar_image_type_name
        FROM player_avatar_images pai
        JOIN avatar_images ai ON pai.avatar_image_id=ai.id
        JOIN avatar_image_types ait ON ai.avatar_image_type_id=ait.id
        WHERE player_id = ? ORDER BY ait.layer_index;";
        $stmt = $this->connect()->prepare($sql);
        $stmt->execute([$this->id]);
        $this->playerAvatarImages = array();

        // We can create items with no DB query by passing the whole row to the PlayerItem constructor
        while ($row = $stmt->fetch())
        {
            array_push($this->playerAvatarImages, new PlayerAvatarImage($row));
        }

    }

    /**
     * addAvatarImage() adds an avatar part to a player's avatar set.
     * If the player already has one of this item type it gets overwritten.
     * @param $arg int or AvatarImage int
     * @param $color1 string Primary Color
     * @param $color2 string Secondary Color
     * @param $color3 string Tertiary Color (rarely used)
     */
    public function addAvatarImage($arg, $color1=null, $color2=null, $color3=null, $color4=null)
    {
        if (is_int($arg)) $avatarImage = new AvatarImage($arg);
        else $avatarImage = $arg;

        $avatarImageId = $avatarImage->getId();

        $sql = "DELETE pai FROM player_avatar_images pai JOIN avatar_images ai ON ai.id=pai.avatar_image_id
                WHERE pai.player_id = ? AND ai.avatar_image_type_id = ?;";
        $stmt = $this->connect()->prepare($sql);
        $stmt->execute([$this->id, $avatarImage->getAvatarImageTypeId()]);

        $sql = "INSERT INTO player_avatar_images (
            player_id,
            avatar_image_id,
            color1,
            color2,
            color3,  
            color4,
            created_at,
            updated_at
        )   
        VALUES (
            ?,
            ?,
            ?,
            ?,
            ?,
            ?,
            now(),
            now()
        );";

        $stmt = $this->connect()->prepare($sql);
        $stmt->execute([
            $this->id,
            $avatarImageId,
            $color1,
            $color2,
            $color3,
            $color4
        ]);

        // Now item is in the player_items table, ensure arrays are updated.
        $this->refreshPlayerAvatarImages();


    }

    /**
     * addItem() accepts an item Id and 'gives' it to the player (for free).
     * If the item is an avatar part, should it replace the existing part of that type?
     *  I'd say the likely answer is YES. There are many examples of where a user has multiple of a part,
     * but this seems more like a bug than intentional.
     * If the item is not, should it take up an inventory slot?
     *  It appears that, yes, non-avatar items need a slot and once they are full the player cannot accept more items.
     * What if the player's slots are all full?
     *  An error will be thrown... the game will have to handle this. The player will probably have to choose to drop
     *  some other item or neglect the new item. Eek, this could get complicated.
     *
     * Should the item be an object instead of an id? Should I accept both?
     * // FIXME: If this is used for more than one item, it doesn't take the stacking max of the item into account.
     *
     * @param $arg  either an id integer OR an item object.
     * @param int $itemAmount  quantity of the item to give the player
     * @param int $questId  Associates the item with a specific quest (used to clean up when quest is complete or dropped)
     * @throws NoBagSlotsAvailableException
     */
    public function addItem($arg, int $itemAmount=1, int $questId=null) {
        // First look up item and throw InvalidItemException if item does not exist
        // This is already handled by the item class, so obvious approach is to instantiate new item
        if (is_int($arg)) $item = new Item($arg);
        else $item = $arg;

        $itemId = $item->getId();

        $remaining = $itemAmount;

        while ($remaining > 0) {

            // This is the itemguid calculation used in player_item_got.jsp
            // https://code.sololearn.com/chZ4v8y3767W/
            // This '1' was added to the end of the string for an unknown reason in the original jsp
            $j = 1;
            // timestamp in ms
            $timestamp = round(microtime(true)*1000);
            $newItemGUID = md5($this->id.$itemId.$timestamp.$j);

            // Default parameters for the player_item record
            $slotId = NULL;



            // Item needs to go into player's inventory, what's the first empty bag slot?
            // this query gets the first empty slot. No results if there are no available slots
            $sql = "SELECT bs.id FROM bag_slots bs
                LEFT OUTER JOIN player_items pi ON bs.id=pi.bag_slot_id AND pi.player_id = ?
                WHERE player_id IS NULL
                ORDER BY bs.id LIMIT 1;";

            $stmt = $this->connect()->prepare($sql);
            $stmt->execute([$this->id]);
            $slotId = $stmt->fetchColumn();
            $isEquipped = 0;

            // If $slot is an integer, add the item with that slot_id
            if (!$slotId) throw new NoBagSlotsAvailableException();


            $sql = "INSERT INTO player_items (
            guid,
            player_id,
            item_id,
            is_equipped,
            bag_slot_id,
            bag_slot_amount,
            quest_id,
            created_at,
            updated_at
        )   
        VALUES (
            ?,
            ?,
            ?,
            b?,
            ?,
            ?,
            ?,
            now(),
            now()
        );";

            $conn = $this->connect();
            $stmt = $conn->prepare($sql);
            $stmt->execute([
                $newItemGUID,
                $this->id,
                $itemId,
                $isEquipped,
                $slotId,
                min($item->getMaxAmount(),$remaining),
                $questId
            ]);

            // Get the playerItemId just inserted so we can use it if there are item variables

            $playerItemId = (int)$conn->lastInsertId();

            // If the item has any variables, generate the player_item_variables now.
            foreach($item->getItemVariables() as $var) {
                $sql = "INSERT INTO player_item_variables (player_id, player_item_id, var_name, var_value, created_at)
                    VALUES (?, ?, ?, ?, now());";
                //var_dump($sql);
                $stmt = $this->connect()->prepare($sql);
                $stmt->execute([
                    $this->id,
                    $playerItemId,
                    $var->getName(),
                    $var->getRandomValue()
                ]);
            }

            // Now item is in the player_items table, ensure arrays are updated.
            $this->refreshPlayerItems();

            $remaining -= min($item->getMaxAmount(),$remaining);
        }//end if


    }

    /**
     * buyItem()
     * Checks that the player has enough money. If so, attempts to add the item and spends the money.
     * This could fail if the player doesn't have enough bag slots.
     * @param mixed $arg -- an item object or an item id
     * @param int $itemAmount defaults to 1, can be more
     * @param int $npcId optionally an NPC id can be specified to be logged.
     * This could possibly be used to check that the purchase is legitimate.
     * @param int $questId optionally log the quest associated with the purchase
     * @throws Exception
     */
    public function buyItem($arg, int $itemAmount=1, int $npcId=null, int $questId=null) {
        if (is_int($arg)) $item = new Item($arg);
        else $item = $arg;
        $itemId = $item->getId();
        $slotsRequired = ceil($itemAmount/$item->getMaxAmount());
        $totalCost = $item->getPrice()*$itemAmount;
        // Check that player has enough money.
        if ($this->money < $totalCost) {
            throw new Exception(_("You don't have enough money."));
        }

        if ($this->bag->getAvailableSlots() < $slotsRequired) {
            throw new Exception(_("You don't have enough room in your bag.").' '.sprintf(ngettext("You need one slot and have none.", "You need %d slots and have %d.", $slotsRequired), $slotsRequired, $this->bag->getAvailableSlots()));
        }
        // Loop batches of the item max_amount until player has purchased all items
        $remaining = $itemAmount;
        while ($remaining > 0) {
            $this->addItem($item, min($item->getMaxAmount(),$remaining), $questId);
            // If that worked, we deduct the funds
            $this->addMoney(-1 * $item->getMaxAmount()*$item->getPrice(), $npcId, $questId);
            $remaining -= min($item->getMaxAmount(),$remaining);
        }
    }

    /**
     * Simple function that changes the amount of money the player has
     * @param int $amount - amount of money to add or remove (if negative)
     * @throws Exception
     */
    public function addMoney(int $amount, int $npcId=null, int $questId=null) {
        if ($this->money + $amount < 0) throw new Exception(_("Player does not have this much money."));
        $sql = "UPDATE players SET money = money + ? WHERE id = ?;
        -- Log purchase
        INSERT INTO money_flow_log (player_id, npc_id, payout, reserve, payout_datetime, quest_id) VALUES (
        ?, ?, ?, 0, NOW(), ?);";
        $stmt = $this->connect()->prepare($sql);
        $stmt->execute([$amount, $this->id,
            $this->id, $npcId, abs($amount), $questId]);

        // Actually modify this object's property
        $this->money+=$amount;
    }

    /**
     * Changes the amount of experience (XP) the player has
     * @param int $amount - amount of XP to add or remove (if negative)
     * @throws Exception
     */
    public function addExperience(int $amount) {
        if ($this->experience + $amount < 0) throw new Exception(_("Player does not have this many XP."));
        $sql = "UPDATE players SET experience = experience + ? WHERE id = ?;";
        $stmt = $this->connect()->prepare($sql);
        $stmt->execute([$amount, $this->id]);

        // Actually modify this object's property
        $this->experience+=$amount;
    }

    public function addProfessionXP($professionId, $professionXP)
    {
        // Add any earned profession XP
        $sql = "UPDATE player_professions SET profession_xp = profession_xp + ?
                WHERE player_id = ? AND profession_id = ?;";
        $stmt = $this->connect()->prepare($sql);
        $stmt->execute([$professionXP, $this->id, $professionId]);

        $this->refreshPlayerProfessions();

    }

    /**
     * hasItem() tests that the player has a quantity of a certain item (1 by default)
     * @param $arg - the id OR item object to check
     * @param int $qty, the player has at least the specified quantity
     */
    public function hasItem($arg, int $qty=1) {
        if (is_int($arg)) $itemId=$arg;
        else $itemId=$arg->getId();

        $sql = "SELECT IFNULL(SUM(bag_slot_amount),0) as item_sum FROM player_items pi ";
        $sql .= " WHERE player_id=:id AND pi.item_id=:itemId ";

        $stmt = $this->connect()->prepare($sql);
        $stmt->bindParam(':id', $this->id, PDO::PARAM_INT);
        $stmt->bindParam(':itemId', $itemId, PDO::PARAM_INT);
        $stmt->execute();

        if ($stmt->fetchColumn()>=$qty) return true;
        else return false;
    }

    /**
     * hasAvatarImage() tests that the player has a certain avatar part
     * @param $arg - the ID or avatarImage object to check
     */
    public function hasAvatarImage($arg)
    {
        if (is_int($arg)) $avatarImageId=$arg;
        else $avatarImageId=$arg->getId();

        $sql = "SELECT 1 FROM player_avatar_images pai
        WHERE player_id = ? AND pai.avatar_image_id = ? ;";

        $stmt = $this->connect()->prepare($sql);
        $stmt->execute([$this->id, $avatarImageId]);

        if ($stmt->fetchColumn()==1) return true;
        else return false;
    }


    /**
     * swapBagSlots calls the playerBag method but additionally updates the player's inventory.
     * Don't normally use this from the player class unless you absolutely need the player's
     * items to be up-to-date. Ordinarily we use the bag anyways, not the playerItems list.
     * There is some cleanup that should be done around this.
     * @param int $srcSlot
     * @param int $destSlot
     */
    public function swapBagSlots(int $srcSlot, int $destSlot) {
        $this->bag->swapBagSlots($srcSlot, $destSlot);
        $this->refreshPlayerItems();
    }


    /**
     * uses the item. The item may have an effect that references the item_effects table.
     * @throws Exception
     * @return string A description of what happened. Can be shown in a toast or modal.
     *
     * // TODO: Does this make more sense as a method of PlayerItem?
     */
    public function useItem($arg):string {
        if (is_string($arg)) $playerItem = new PlayerItem($arg);
        else $playerItem = $arg;
        // Check that this player is the owner
        if ($playerItem->getOwnerPlayerId() != $this->id) {
            throw new Exception('You do not own this item and cannot use it.');
        }
        // If the player object calls this, first the requisite level will need to be checked.
        if ($playerItem->getRequiredLevel() > $this->maxLevel) {
            throw new Exception( sprintf(_('You must be level %d to use this item.'),$playerItem->getRequiredLevel()) );
        }

        // The effect will depend on which effect id it has. Current effects are:
        // 1 eat, 2 quest_activate, 3 dig
        switch ($playerItem->getEffectId()) {
            case 1: // eat
                if (is_null($playerItem->getEffectParameters()))
                    throw new Exception('No argument passed to useItem. Integer parameter is required.');
                $addedEnergy = (int)$playerItem->getEffectParameters()*100;
                $this->movement +=  $addedEnergy;
                $sql = "UPDATE players SET movement=? WHERE id = ?;";
                $stmt = $this->connect()->prepare($sql);
                $stmt->execute([$this->movement, $this->id]);
                // The item is consumed.
                $playerItem->adjustSlotAmount(-1);
                return 'You finish eating and gain '.$addedEnergy.' energy.';
                break;
            case 2: // activate_quest
                if (is_null($playerItem->getEffectParameters()))
                    throw new Exception('No argument passed to useItem. Integer quest_id is required.');
                return 'TODO: This item should give you quest_id '.$playerItem->getEffectParameters().'.';
            case 3: // dig
                // Look up any quests the player has that this item is a tool for.
                $sql = "SELECT * FROM quest_tools WHERE item_id = ? AND quest_id IN
                (SELECT quest_id FROM player_quests WHERE player_id = ? AND success_time IS NULL)";
                $stmt = $this->connect()->prepare($sql);
                $stmt->execute([$playerItem->getId(), $this->id]);
                $html = '';
                while ($row = $stmt->fetch()) {
                    $tool = new QuestTool($playerItem->getGUID(), $row['quest_id']);
                    // If the item is usable at this location, it will return information to the player.
                    $html .= $tool->useAtLocation($this->mapId, $this->x, $this->y);
                }

                if (strlen($html)) {
                    return $html;
                } else {
                    return '<div class="text-center">'._("You tried digging here but didn't find anything interesting.").'</div>';
                }

            default:
                return "You can't seem to use this item.";
        }
    }

    /**
     * splitItem - if an item has a count > 1, the player can specify a quantity to move into a new, unique
     * GUID in a separate inventory slot (presuming they have one.
     * @param PlayerItem|int $arg - Either a playerItem or playerItem GUID
     * @param int $amount - The amount of the item to split off
     */
    public function splitItem($arg, int $amount=1) {
        if (is_string($arg)) $playerItem = new PlayerItem($arg);
        else $playerItem = $arg;
        // Check that this player is the owner
        if ($playerItem->getOwnerPlayerId() != $this->id) {
            throw new Exception('You do not own this item and cannot split it.');
        }

        if ($playerItem->getSlotAmount() <= 0) throw new Exception(_("You can't split an item into fewer than one."));
        if ($playerItem->getSlotAmount() <= $amount) throw new Exception(_("You can only split fewer of an item than there is of it."));

        // Now subtract the amount from the original playerItem.
        $playerItem->adjustSlotAmount(-1*$amount);
        // Give the player the specified quantity of the item, then reduce the original item by that amount.
        $this->addItem($playerItem, $amount);

        // This might not be super important but ensures the object accurately reflects the items the player has (at the cost of a query).
        $this->refreshPlayerItems();
    }

    /**
     * stackItem - given an item, finds other items in the bag of the same type that are able to be stacked.
     * If this slot has remaining capacity, reduce other items by the min of their amount and remaining capacity.
     * @param mixed $arg Either a playerItem object or an itemGUID for one
     * @return string A message indicating how many items have been stacked.
     */
    public function stackItem($arg) {
        if (is_string($arg)) $playerItem = new PlayerItem($arg);
        else $playerItem = $arg;
        // Check that this player is the owner
        if ($playerItem->getOwnerPlayerId() != $this->id) {
            throw new Exception('You do not own this item and cannot split it.');
        }
        $capacityRemaining = $playerItem->getMaxAmount() - $playerItem->getSlotAmount();
        if ($capacityRemaining <= 0) throw new Exception(_("There is no room in this slot to stack more items."));

        // Get an array of other items with the same id
        $otherItems = $this->bag->getItemsWithSameId($playerItem->getId(), true, $playerItem->getGUID());
        if (sizeof($otherItems) == 0) throw new Exception(_("There are no other items of this kind to stack that aren't full."));

        // If there are other items, loop through them until this stack is full
        $totalChange = 0;
        foreach($otherItems as $otherItem) {
            $adjustment = min($capacityRemaining, $otherItem->getSlotAmount());
            $playerItem->adjustSlotAmount($adjustment);
            $otherItem->adjustSlotAmount(-1*$adjustment);
            // Reduce capacity by the adjustment and return if we're out of capacity
            $totalChange+=$adjustment;
            $capacityRemaining-=$adjustment;
            if ($capacityRemaining<=0) break;
        }

        return sprintf(ngettext("One more of the item has been stacked into the slot.", "%d more of the item have been stacked into the slot.", $totalChange), $totalChange);

    }

    /**
     * addProfession
     * @param $arg -- either professionId or profession object.
     * @throws Exception
     */
    public function addProfession($arg) {
        if (is_int($arg)) $profession = new Profession($arg);
        else $profession = $arg;

        if ($profession->playerIsEligible($this->id)) {
            // Ensure the player doesn't already have this profession
            foreach ($this->professions as $currProf) {
                if ($currProf->getId() == $profession->getId())
                    throw new Exception(_('Player already has this profession.'));
            }
        } else throw new Exception(_('Player does not meet prerequisites for this profession.'));

        // Insert into player_professions DB table.
        $sql = "INSERT INTO player_professions (player_id, profession_id, profession_xp, profession_level, created_at)
        VALUES(?, ?, 0, 0, now());";
        $stmt = $this->connect()->prepare($sql);
        $stmt->execute([$this->id, $profession->getId()]);
    }

    /**
    * Attempts to move the player an increment on X and/or Y axes.
    * @param int $xInc specifies E (+1) or W (-1)
    * @param int $yInc specifies N (+1) or S (-1)
    */
    public function move(int $xInc, int $yInc) {
        $canMove = true;
        if (abs($xInc)>1 || abs($yInc)>1) {
            //echo "Moving more than one unit in each direction is not permitted";
            // If I throw an exception, the text of it could be shown in a toast.
            $canMove = false;
            return; // This function only supports moving a single square in each direction,
            // you can move diagonally
        }
        // There's an easy way and a hard way of doing this...
        // The easy way is to simply increment the player as instructed.
        // The right way is to test that the player can actually move from their current location,
        // and only move if they can.
        // BTW, what happens if the tile doesn't exist? I guess we throw an exception
        $targetTile = new MapTile($this->mapId, $this->x+$xInc, $this->y+$yInc);
        $skillReq = $targetTile->getSkillIdReq();
        // Check that player has ability to move to this tile
        if (!is_null($skillReq) && !in_array($skillReq, $this->skillIds)) {
            // echo "Player does not have required skill";
            $canMove = false;
        }

        $movReq = 0;
        if ($xInc!=0 || $yInc!=0) $movReq = $targetTile->getMovementReq();
        // Check that player has sufficient energy 
        if ($this->movement < $movReq) {
            $canMove = false;
        }

        // If the player cannot move, we log this to the DB
        if (!$canMove) {
            // Note that we log the x and y that the player ATTEMPTED UNSUCCESSFULLY to move to
            $sql = "INSERT INTO player_actions_log (user_id, player_id, map_id, x, y, event_time, player_action_type_id, note) VALUES
            (?, ?, ?, ?, ?, NOW(3), ?, NULL);";
            $stmt = $this->connect()->prepare($sql);
            $stmt->execute([$this->userId, $this->id, $this->mapId, $this->x+$xInc, $this->y+$yInc, Actions::MOVE_WITHOUT_ENERGY_OR_SKILL]);

            // Could throw an exception here and show this via toast message or something.
            return;
        }


        $this->movement-=$targetTile->getMovementReq();
        $this->x = $this->x+$xInc;
        $this->y = $this->y+$yInc;
        // So far everything is looking okay, increment the x and y appropriately
        $sql = "UPDATE players SET x = ?, y = ?, movement = ?, visible = 1, last_action_time = NOW() WHERE id = ?;
        UPDATE players SET visible=0 WHERE visible=1 AND TIMESTAMPDIFF(SECOND, last_action_time, NOW()) > ?;
        -- Log player's movement
        INSERT INTO player_actions_log (user_id, player_id, map_id, x, y, event_time, player_action_type_id, note) VALUES
        (?, ?, ?, ?, ?, NOW(3), ?, NULL);";

        $stmt = $this->connect()->prepare($sql);
        $stmt->execute([$this->x, $this->y, $this->movement, $this->id, Config::VISIBLE_FOR_SECONDS,
            $this->userId, $this->id, $this->mapId, $this->x, $this->y, Actions::MOVE_WITH_ENERGY]);


        // Insert record into wandering_behaviour log

    }

    /**
    * Attempts to use a portal to "teleport" to a different map and location
    * @param bid = building id to attempt to use
    */
    public function usePortal(int $bid) {
        // We stipulate that the player must be on the same tile as this building in order to use its portal.
        $building = new Building($bid);

        if (!$building->playerAllowed($this->id)) {
            // How to return an error message here?
            return false;
        }

        if ($building->getMapId() == $this->mapId && $building->getX() == $this->x && $building->getY() == $this->y) {

            // We record the original coordinates so we can submit them to the log
            $origMap=$this->mapId; $origX=$this->x; $origY=$this->y;
            $this->mapId = $building->getDestMapId();
            $this->x = $building->getDestX();
            $this->y = $building->getDestY();
            $this->lastActionTime = date("Y-m-d H:i:s");
            if ($origMap != $this->mapId) $this->mapEnterTime = date("Y-m-d H:i:s");
            $sql = "UPDATE players SET x= ?, y= ?, map_id= ?, last_action_time=NOW(), map_enter_time= ? WHERE id=?;
            -- Two entries to wandering log - one for move_portal (source) another for teleport (destination)
            INSERT INTO player_actions_log (user_id, player_id, map_id, x, y, event_time, player_action_type_id, note) VALUES
            (?, ?, ?, ?, ?, NOW(3), ?, NULL), (?, ?, ?, ?, ?, NOW(3), ?, NULL);";
            $stmt = $this->connect()->prepare($sql);
            $stmt->execute([$this->x, $this->y, $this->mapId, $this->mapEnterTime, $this->id,
                $this->userId, $this->id, $origMap, $origX, $origY, Actions::MOVE_PORTAL,
                $this->userId, $this->id, $this->mapId, $this->x, $this->y, Actions::TELEPORT]);
            // Insert record into wandering_behaviour log

            return true;

        } else {
            // Could throw exception or return error or something
            // echo "Player is not at this location.";
            return false;
        }
    }

    /**
     * Attempts to use an NPC portal to "teleport" to a different map and location
     * @param mixed $arg = id of the NPC's portal or the NpcPortal object
     * @param Npc $npc = npc that the player is using the portal with.
     * This is optional to improve efficiency so we don't have to instantiate an NPC object
     * @throws Exception
     */
    public function useNpcPortal($arg, Npc $npc=null) {
        if (is_int($arg)) $npcPortal = new NpcPortal($arg);
        else $npcPortal = $arg;
        // Check that the player is on the NPC's home.
        if (is_null($npc)) $npc = new Npc($npcPortal->getNpcId());
        // Does this NPC own the portal?
        if ($npcPortal->getNpcId() != $npc->getId()) {
            throw new Exception("The specified NPC doesn't own this portal.");
        }
        // Is the player in a location where the NPC can be found?
        if (!$npc->isNpcFoundAt($this->mapId, $this->x, $this->y)) {
            throw new Exception("This NPC is not found at your current location.");
        }

        // Does the player have enough money to use the portal?
        if ($this->money < $npcPortal->getPrice()) {
            throw new Exception(_("You don't have enough money to use this portal."));
        }

        if ($this->maxLevel < $npcPortal->getLevel()) {
            throw new Exception(_("You aren't a high enough level to use this portal."));
        }

        // If all those checks passed, we can teleport the player
        // We record the original coordinates so we can submit them to the log
        $origMap=$this->mapId; $origX=$this->x; $origY=$this->y;
        // I also have to check that the player has the required level
        $this->money -= $npcPortal->getPrice();
        $this->mapId = $npcPortal->getDestMapId();
        $this->x = $npcPortal->getDestX();
        $this->y = $npcPortal->getDestY();
        $sql = "UPDATE players SET x=?, y=?, map_id=?, money=? WHERE id=?;
            -- Two entries to player_action_log - one for teleport_offered_by_npc (source) another for teleport (destination)
            INSERT INTO player_actions_log (user_id, player_id, map_id, x, y, event_time, player_action_type_id, note) VALUES
            (?, ?, ?, ?, ?, NOW(3), ?, NULL), (?, ?, ?, ?, ?, NOW(3), ?, NULL);";
            $stmt = $this->connect()->prepare($sql);
            $stmt->execute([$this->x, $this->y, $this->mapId, $this->money, $this->id,
                $this->userId, $this->id, $origMap, $origX, $origY, Actions::TELEPORT_OFFERED_BY_NPC,
                $this->userId, $this->id, $this->mapId, $this->x, $this->y, Actions::TELEPORT]);

    } // end useNpcPortal()

    /**
     * Gives the player a quest if they are eligible for it.
     * @param mixed $arg  questId or Quest object.
     * @param Npc $npc  An NPC can be specified to avoid having to instantiate a new NPC
     *
     * @return string
     */
    public function takeQuest($arg, Npc $npc=null):string {
        if (is_int($arg)) $quest = new Quest($arg);
        else $quest = $arg;
        // This assumes that the quest comes from an NPC. I believe it's possible to get quests from an item.
        // This class could be upgraded to handle that if I actually see this in practice.

        // Check that the player is on the NPC's home.
        if (is_null($npc)) $npc = new Npc($quest->getGiverNpcId());
        // Is this the NPC that gives the quest?
        if ($quest->getGiverNpcId() != $npc->getId()) {
            throw new Exception("The specified NPC doesn't offer this quest.");
        }
        // Is the player in a location where the NPC can be found?
        if (!$npc->isNpcFoundAt($this->mapId, $this->x, $this->y)) {
            throw new Exception("The NPC offering this quest is not found at your current location.");
        }

        // Check that the player qualifies by ensuring that this quest is in the list of quests that the NPC offers.
        $quests = $npc->getQuestsForPlayer($this->id);
        $questAvailable=false;
        foreach ($quests as $q) {
            if ($q->getId() == $quest->getId()) {
                $questAvailable=true;
                break;
            }
        }
        if (!$questAvailable) {
            throw new Exception(_("It doesn't seem that the NPC is offering this quest to you at the moment."));
        }

        // It looks like the player is eligible to take the quest. Add to the player's quest list
        // and log the appropriate things.
        $sql = "DELETE FROM player_quests WHERE player_id = ? AND quest_id= ?; ";
        $sql .= "INSERT INTO player_quests (player_id, quest_id, pickup_time) VALUES(?, ?, NOW()); ";
        $sql .= "INSERT INTO player_quests_log (player_id, quest_id, event_datetime, quest_event_id, npc_id, map_id, x, y) VALUES (
            ?, ?, NOW(), ?, ?, ?, ?, ?);";
        $stmt = $this->connect()->prepare($sql);
        $stmt->execute([
            $this->id, $quest->getId(),
            $this->id, $quest->getId(),
            $this->id, $quest->getId(), QuestEvents::PICK_UP, $npc->getId(), $this->mapId, $this->x, $this->y
        ]);

        // If npc_has_quest_item, give player any items the giver npc has for this quest.
        // iterate through NPC items where the quest_id is this quest and add them to the player
        $noticeText = "";
        $notEnoughRoom = 0;
        if ($quest->isNpcHasQuestItem())
        {
            $questItems = $npc->getItemsForQuest($quest->getId());
            foreach($questItems as $item) {
                if (strlen($noticeText) == 0) {
                    $noticeText = '<i class="fas fa-shopping-bag" style="margin-right:4px;"></i> <strong>'._("You have received the following").'</strong>' .
                        '<ul class="mt-2 ml-2">';
                }
                // Only where questId is this quest
                try {
                    $this->addItem($item, 1, $quest->getId());
                    $noticeText .= '<li><i class="fas fa-check-circle text-green-500 dark:text-green-400" style="margin-right:8px"></i>'.$item->getName();
                    if ($item->getAmount() > 1) $noticeText .= " <strong>(".$item->getAmount().")</strong>";
                    $noticeText .= "</li>";
                } catch (Exception $e) {
                    $notEnoughRoom++;
                    $noticeText .= '<li class="error"><i class="fas fa-times-circle mr-2 text-red-600 dark:text-red-500"></i>'._("No room for").' '.$item->getName().'</li>';
                }
            }

            // Close the ul if necessary
            if (strlen($noticeText)) $noticeText .= "</ul>";

            // if we got an exception, we assume the player doesn't have room in their bag and show a message to that effect.
            if ($notEnoughRoom) {
                $noticeText .= '<p class="error"><strong>'._("Your bag is full!").'</strong> ' .
                    sprintf(ngettext("Get this item from %s", "Get these items from %s", $notEnoughRoom), $npc->getName()).' '._("after freeing up space.").'</p>';
            }
        }

        // If the quest has any variables, generate the player_variables now.
        foreach($quest->getQuestVariables() as $var) {
            // First ensure we don't have duplicate variables, we only allow one type.
            // This is in case we don't do a perfect job of cleaning unused variables out.
            $sql = "DELETE FROM player_quest_variables WHERE player_id = ? AND quest_id = ? AND var_name = ?;";
            $sql.= "INSERT INTO player_quest_variables (player_id, quest_id, var_name, var_value, created_at) VALUES (?, ?, ?, ?, ?)";
            $stmt = $this->connect()->prepare($sql);
            $stmt->execute([
                $this->id, $var->getQuestId(), $var->getName(),
                $this->id, $var->getQuestId(), $var->getName(), $var->getRandomValue(), date("Y-m-d H:i:s")
            ]);
        }

        // Update player's quest list
        $this->refreshPlayerQuests();

        return $noticeText;

    }// end takeQuest()

    /**
     * Checks that the player does have the quest. If so, returns the playerQuest object.
     * If not, returns false.
     * @param int $questId
     * @return mixed
     */
    public function getPlayerQuestWithId($questId)
    {
        foreach($this->playerQuests as $pq) {
            if ($pq->getId() == $questId) {
                return $pq;
            }
        }
        return false;
    }

    /**
     * Checks that the player has the given profession
     * @param int $professionId
     * @return bool
     */
    public function playerHasProfession(int $professionId):bool
    {
        foreach ($this->professions as $profession) {
            if ($profession->getId() == $professionId) return true;
        }
        return false;
    }


    /**
     * Determine if the player should be levelled up. This can be run after each time the player receives profession XP.
     * If they have the number of XP required to get to the next level of a profession, the level will be incremented
     * unless they are already at the maximum level.
     *
     * Additionally, when the player increases a level in any profession, they will get a bonus_point.
     * @param int|null $professionId
     *
     */
    public function levelUp(int $professionId=null)
    {
        $levelMessages = "";
        foreach($this->getProfessions() as $playerProfession) {
            if (is_null($professionId) || $professionId == $playerProfession->getId()) {
                if ($playerProfession->levelUp()) {
                    $levelMessages.='<div class="levelUp text-center text-green-500 dark:text-green-400">'.$playerProfession->getName().' '.sprintf(_("level %d achieved."), $playerProfession->getProfessionLevel()).'</div>';
                }
            }
        }
        return $levelMessages;
    }



    /**
    * getClientPlayerItemsEquippedData: Returns essential equipped playerItem data for client-side interaction
    */
    public function getClientPlayerItemsEquippedData() {
        $itemData = array();
        forEach($this->playerAvatarImages as $item) {
            array_push($itemData, $item->getClientPlayerItemData());
        }
        return $itemData;
    }

    /**
    * getClientPlayerItemsStoredData: Returns essential stored playerItem data for client-side interaction
    */
    public function getClientPlayerItemsStoredData() {
        $itemData = array();
        forEach($this->playerAvatarImages as $item) {
            array_push($itemData, $item->getClientPlayerItemData());
        }
        return $itemData;
    }

    /**
    * getClientPlayerData: Returns essential player data for client-side interaction
    * This is going to be *frequently* refreshed so we want to limit this to things that change regularly.
    * I'm storing as associative array with small names for efficiency
    */
    public function getClientPlayerData() {
        $playerData = array();
        $playerData['map'] = $this->mapId;
        $playerData['x'] = $this->x;
        $playerData['y'] = $this->y;
        $playerData['h'] = $this->health;
        $playerData['hmx'] = $this->healthMax;
        // $playerData['mna'] = $this->getMana(); // mana wasn't normally retreived this way as it doesn't change
        $playerData['mny'] = $this->money;
        $playerData['lvl'] = $this->maxLevel;
        $playerData['mv'] = $this->movement;
        $playerData['at'] = $this->attack;
        $playerData['df'] = $this->defence;
        $playerData['bp'] = $this->bonusPoint;
        $playerData['xp'] = $this->experience;
        // Make items separate as they are quite hefty chunks of data
        // and they don't change all that often.
        //$playerData['iEq'] = $this->getClientPlayerItemsEquippedData();
        //$playerData['iSt'] = $this->getClientPlayerItemsStoredData();
        $playerData['pr'] = array();
        foreach ($this->professions as $profession) {
            array_push($playerData['pr'], $profession->getClientPlayerProfessionData());
        }
        $playerData['stats'] = $this->stats;
        $playerData['skl'] = $this->skillIds;

        // I think quest data is small enough that I can just include it here.
        $playerData['q'] = array();
        foreach ($this->playerQuests as $playerQuest) {
            array_push($playerData['q'], $playerQuest->getClientPlayerQuestData());
        }

        return $playerData;

    }

    // Chat Classes
    /**
     * Get a list of chat messages relevant to the specified parameters
     * @param $afterChatId - Optionally only retrieve messages with chatId greater than this
     * @return array
     */
    public function getMessages(int $afterChatId=null) {
        // update the lastChatId from the chat_log table in the session so we don't see any messages
        // that were sent when we were out of range.
        if (isset($_SESSION['lastChatId'])) {
            $sql = "SELECT MAX(id) FROM chat_log;";

            $stmt = $this->connect()->prepare($sql);
            $stmt->execute();
            $_SESSION['lastChatId'] = (int)$stmt->fetchColumn();
        }
        $sql="SELECT cl.id, player_id_src,
            ps.name AS src_name, player_id_tgt, pt.name AS tgt_name,
            message_time, message, cl.map_id, cl.x, cl.y
            FROM chat_log cl
            LEFT JOIN players ps ON cl.player_id_src=ps.id
            LEFT JOIN players pt ON cl.player_id_tgt=pt.id
            WHERE message_time>=:startTime
            -- Factor in the chat range from Config. Still allow players to receive private messages even when they are out of range 
            AND ((cl.map_id=:mapId AND ABS(cl.x-:playerX)<=" . Config::MAX_CHAT_RANGE . " AND ABS(cl.y-:playerY)<=" . Config::MAX_CHAT_RANGE . "
                
            ) OR player_id_tgt=:tgt )
            AND (player_id_tgt=:tgt OR player_id_tgt=0 OR player_id_tgt IS NULL OR player_id_src=:src OR player_id_tgt=0 OR player_id_tgt IS NULL) ";

        if (!is_null($afterChatId)) {
            $sql .= " AND cl.id > :afterChatId";
        }

        $sql .= " ORDER BY message_time ASC;";

        $stmt = $this->connect()->prepare($sql);
        $stmt->bindParam(':mapId', $this->mapId, PDO::PARAM_INT);
        $stmt->bindParam(':playerX', $this->x, PDO::PARAM_INT);
        $stmt->bindParam(':playerY', $this->y, PDO::PARAM_INT);
        // These are the same variable
        $stmt->bindParam(':tgt', $this->id, PDO::PARAM_INT);
        $stmt->bindParam(':src', $this->id, PDO::PARAM_INT);
        $stmt->bindParam(':startTime', $this->mapEnterTime, PDO::PARAM_STR);
        if (!is_null($afterChatId)) $stmt->bindParam(':afterChatId', $afterChatId, PDO::PARAM_INT);
        $stmt->execute();

        // Return an array of messages;
        return $stmt->fetchAll(PDO::FETCH_ASSOC);

    }// end getMessages()



    /**
     * Insert a new message into the chat_log DB table
     * @param $message - contents of the message
     * @param $playerIdTgt - id message was whispered to, if any\
     * @return int
     */
    public function sendMessage(string $message, int $playerIdTgt=null):int {
        // Insert into the DB, then invoke the constructor
        $dbh = new Dbh();

        $sql = "INSERT INTO chat_log (
            player_id_src,
            player_id_tgt,
            message_time,
            message,
            map_id,
            x,
            y)
        VALUES(
            ?,
            ?,
            NOW(),
            ?,
            ?,
            ?,
            ?);
        -- Also ensure the player remains visible if they are actively chatting.
        UPDATE players SET last_action_time=NOW(), visible=1 WHERE id= ?";
        $conn = $dbh->connect();
        $stmt = $conn->prepare($sql);
        $this->lastActionTime = date("Y-m-d H:i:s");
        $stmt->execute([
            $this->id,
            $playerIdTgt,
            htmlspecialchars($message), // encode so it displays as typed, not interpreted as HTML/JS. Could support markdown in the future.
            $this->mapId,
            $this->x,
            $this->y,
            $this->id]);
        // get the new chat_log id in case it'll be useful
        return (int)$conn->lastInsertId();

    }// end sendMessage static method

    /**
     * Intended to be used to send minimal information about other players on a map to clients
     * This is only supposed to be called for yet-unknown players
     */
    public function getClientOtherPlayerData() {
        $playerData = array();
        $playerData['id'] = (int)$this->id;
        $playerData['name'] = $this->name;
        // This is irrelevant as the players will always be on the same map.
        // $playerData['map'] = (int)$this->id;
        $playerData['x'] = (int)$this->x;
        $playerData['y'] = (int)$this->y;
        $playerData['vis'] = $this->visible;
        // It might not be super efficient to get this every time.
        // Can we do this as a separate process so the images can get cached somehow?
        $playerData['avatar'] = $this->showAvatar();

        return $playerData;

    }

    /**
     * This object method gets all the players currently visible on the map. This function is used primarily
     * when creating a map object, but it could be used to update the players as well periodically.
     * I worry a bit that creating a player object is overkill given we only really need their names and avatar images
     */
    protected function updateVisiblePlayers() {
        $sql = "SELECT p.id, p.name, user_id, birthplace_id, visible, map_id, x, y, last_action_time, map_enter_time,
        health, health_max, money, experience, repute_radius, movement, travel, attack, defence, bonus_point, race_id,
        r.name AS race_name, gender_id, g.name AS gender_name, is_super                
        FROM players p
        JOIN races r ON p.race_id=r.id
        JOIN genders g ON p.gender_id=g.id
        WHERE visible=1 AND map_id = ?
        AND ABS(x - ?) <= ".Config::MAX_CHAT_RANGE." AND ABS(y - ?) <= ".Config::MAX_CHAT_RANGE.";";
        $stmt = $this->connect()->prepare($sql);
        $stmt->execute([$this->mapId, $this->x, $this->y]);
        $this->visiblePlayers = array();
        while($row = $stmt->fetch()) {
            // The 'true' means we create a simplified player object without some data we won't need here.
            array_push($this->visiblePlayers, new Player($row, true));
        }
    }

    /**
     * This function gets the up-to-date list of players on the map
     */
    public function getVisiblePlayers() {
        $this->updateVisiblePlayers();
        return $this->visiblePlayers;
    }

    /**
     * This returns the simplified client-side array of player data used to show other players on the map
     */
    public function getClientVisiblePlayersData() {
        $otherPlayers = array();
        $this->updateVisiblePlayers();
        foreach($this->visiblePlayers as $player) {
            // only push to the array if this player isn't the current player
            if ($player->getId() != $this->id) {
                array_push($otherPlayers, $player->getClientOtherPlayerData());
            }
        }
        return $otherPlayers;
    }


    /**
     * getVisiblePlayerPositions
     * This is more lightweight than getVisiblePlayers, it only returns the positions
     * Simply returns an array of the visible playerIds on this map along with their x and y positions
     * This is used for constantly keeping player positions up to date so it needs to be lean
     */
    public function getVisiblePlayerPositions() {
        $sql = "SELECT id, x, y FROM players WHERE visible=1 AND map_id=:id
        AND ABS(x - :playerX) <= ".Config::MAX_CHAT_RANGE." AND ABS(y - :playerY) <= ".Config::MAX_CHAT_RANGE."
        AND id != :currentPlayerId;";
        $stmt = $this->connect()->prepare($sql);
        $stmt->bindValue(':id', $this->mapId, PDO::PARAM_INT);
        $stmt->bindValue(':currentPlayerId', $this->getId(), PDO::PARAM_INT);
        $stmt->bindValue(':playerX', $this->x, PDO::PARAM_INT);
        $stmt->bindValue(':playerY', $this->y, PDO::PARAM_INT);

        $stmt->execute();
        $playerPositions = array();
        while($row = $stmt->fetch()) {
            $pp = array();
            array_push($pp, (int)$row['id']);
            array_push($pp, (int)$row['x']);
            array_push($pp, (int)$row['y']);
            array_push($playerPositions, $pp);
        }
        return $playerPositions;
    }


    /**
     * Marks the player as invisible and handles any logout related actions
     */
    public function leave() {
        // This won't do much good if I don't do something with the last_action_time, like nullify it.
        // I have to change the DB schema to allow for that
        $sql = "UPDATE players SET visible=0 WHERE id = ?;";
        $stmt = $this->connect()->prepare($sql);
        $stmt->execute([$this->id]);
        $this->visible = false;
    }

    /**
     * Deletes the specified player and (almost) all information associated with the player.
     * Log entries pertaining to the player's actions are retained.
     * @param $arg any id or name of player. Argument is presumed to be an ID, but test scripts must be able to delete
     * by the player's name.
     */
    static public function delete($arg)
    {
        $idOrName = 'id';
        if (!is_int($arg)) $idOrName = 'name';
        $sql = "
            DELETE p2 FROM players p JOIN player_quest_variables	p2 ON p.id=p2.player_id WHERE p.$idOrName = ?;
            DELETE p2 FROM players p JOIN player_quests 		p2 ON p.id=p2.player_id WHERE p.$idOrName = ?;
            DELETE p2 FROM players p JOIN player_skills		    p2 ON p.id=p2.player_id WHERE p.$idOrName = ?;
            DELETE p2 FROM players p JOIN player_professions    p2 ON p.id=p2.player_id WHERE p.$idOrName = ?;
            DELETE p2 FROM players p JOIN player_stats 		    p2 ON p.id=p2.player_id WHERE p.$idOrName = ?;
            DELETE p2 FROM players p JOIN player_items 		    p2 ON p.id=p2.player_id WHERE p.$idOrName = ?;
            DELETE p2 FROM players p JOIN player_base_attributes p2 ON p.id=p2.player_id WHERE p.$idOrName = ?;
            DELETE FROM players WHERE $idOrName = ?;
        ";
        $dbh = new Dbh();
        $stmt = $dbh->connect()->prepare($sql);
        $stmt->execute([$arg, $arg, $arg, $arg, $arg, $arg, $arg, $arg]);
    }


} //end class Player
